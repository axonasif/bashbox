#!/usr/bin/env bash
main@bashbox%8089 () 
{ 
    \command \unalias -a;
    set -o pipefail;
    set -o errexit;
    set -o errtrace;
    set -o nounset;
    shopt -s expand_aliases;
    trap '____r=$?; BB_ERR_SOURCE="${BASH_SOURCE[0]}" println::error "$BASH_COMMAND" $____r; exit $____r' ERR;
    function println::error () 
    { 
        local _return_code=${2:-$?};
        local _source="${BB_ERR_SOURCE:-"${BASH_SOURCE[0]}"}";
        local _command="$1";
        test "${_PRINT_HELP:-no}" == yes && print_help 1>&2;
        echo -e "[!!!] \033[1;31mERROR\033[0m[$_return_code]: $_source[$BASH_LINENO]: $_command";
        case "${JOB:-"exit"}" in 
            exit)
                exit $_return_code
            ;;
            kill)
                kill -9 "$BASHPID"
            ;;
        esac
    };
    ___self="$0";
    ___MAIN_FUNCNAME="main@bashbox%8089";
    NAME="bashbox";
    AUTHORS=("AXON <axonasif@gmail.com>");
    VERSION="0.1.5";
    DEPENDENCIES=("std::0.1.2" "argbash::0.1.0");
    REPOSITORY="https://github.com/axonasif/bashbox";
    function bb_bootstrap_header () 
    { 
        \command \unalias -a;
        set -o pipefail;
        set -o errexit;
        set -o errtrace;
        set -o nounset;
        shopt -s expand_aliases;
        trap '____r=$?; BB_ERR_SOURCE="${BASH_SOURCE[0]}" println::error "$BASH_COMMAND" $____r; exit $____r' ERR
    };
    readonly _bashbox_meta_name="Bashbox.meta";
    readonly _src_dir_name="src";
    readonly _bashbox_home="${HOME:-"${0%/*}"}/.bashbox" && mkdir -p "$_bashbox_home";
    readonly _bashbox_registrydir="$_bashbox_home/registry" && mkdir -p "$_bashbox_registrydir";
    readonly _bashbox_bindir="$_bashbox_home/bin" && mkdir -p "$_bashbox_bindir";
    readonly _bashbox_posix_envfile="$_bashbox_home/env";
    readonly _bashbox_fish_envfile="$_bashbox_home/env.fish";
    readonly SUBCOMMANDS_DESC=("" "Create a new bashbox project" "Directly run a bashbox project" "Compile a bashbox project" "Cleanup target/ directories" "Install a bashbox project from repo" "Install bashbox into PATH");
    _var_exports=(_bashbox_registrydir);
    for _var in "${_var_exports[@]}";
    do
        { 
            export "$_var"
        };
    done;
    ( for _envfile in "$_bashbox_posix_envfile" "$_bashbox_fish_envfile";
    do
        { 
            if test ! -e "$_envfile"; then
                { 
                    case "$_envfile" in 
                        "$_bashbox_posix_envfile")
                            echo "export PATH=\"$_bashbox_bindir:\$PATH\"" > "$_envfile"
                        ;;
                        "$_bashbox_fish_envfile")
                            echo "set PATH \"$_bashbox_bindir\" \"\$PATH\" && export PATH" > "$_envfile"
                        ;;
                    esac
                };
            fi
        };
    done ) & function coming_soon () 
    { 
        println::error "In progress, coming in one of the future updates, try again later";
        echo "nah"
    };
    function geco () 
    { 
        echo -e "$@"
    };
    function println::helpgen () 
    { 
        _positionals=();
        _arg_helpname=;
        _arg_short_desc=;
        _arg_usage=;
        _arg_options_desc=;
        _arg_subcommands=;
        _arg_examples=;
        _arg_footer_msg=;
        function print_help () 
        { 
            printf '%s\n' "<The general help message of my script>";
            printf 'Usage: %s [--short-desc <arg>] [--usage <arg>] [--options-desc <arg>] [--subcommands <arg>] [--examples <arg>] [--footer-msg <arg>] [-h|--help] <helpname>\n' "$0";
            printf '\t%s\n' "-h, --help: Prints help"
        };
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                _key="$1";
                case "$_key" in 
                    --short-desc)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_short_desc="$2";
                        shift
                    ;;
                    --short-desc=*)
                        _arg_short_desc="${_key##--short-desc=}"
                    ;;
                    --usage)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_usage="$2";
                        shift
                    ;;
                    --usage=*)
                        _arg_usage="${_key##--usage=}"
                    ;;
                    --options-desc)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_options_desc="$2";
                        shift
                    ;;
                    --options-desc=*)
                        _arg_options_desc="${_key##--options-desc=}"
                    ;;
                    --subcommands)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_subcommands="$2";
                        shift
                    ;;
                    --subcommands=*)
                        _arg_subcommands="${_key##--subcommands=}"
                    ;;
                    --examples)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_examples="$2";
                        shift
                    ;;
                    --examples=*)
                        _arg_examples="${_key##--examples=}"
                    ;;
                    --footer-msg)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_footer_msg="$2";
                        shift
                    ;;
                    --footer-msg=*)
                        _arg_footer_msg="${_key##--footer-msg=}"
                    ;;
                    -h | --help)
                        print_help;
                        exit 0
                    ;;
                    -h*)
                        print_help;
                        exit 0
                    ;;
                    *)
                        _last_positional="$1";
                        _positionals+=("$_last_positional");
                        _positionals_count=$((_positionals_count + 1))
                    ;;
                esac;
                shift;
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'helpname'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_helpname ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                test $# -gt 0 || break;
                eval "$_positional_name=\${1}" || println::error "Error during argument parsing." 1;
                shift;
            done
        };
        parse_commandline "$@";
        handle_passed_args_count;
        assign_positional_args 1 "${_positionals[@]}";
        echo -e "${_arg_helpname}\c";
        if test -n "$_arg_short_desc"; then
            echo -e " - $_arg_short_desc\n";
        else
            echo;
        fi;
        if test -n "$_arg_usage"; then
            echo -e "USAGE:";
            while read -r line; do
                echo -e "    $line";
            done < <(echo "$_arg_usage");
            echo;
        fi;
        for child in "$_arg_options_desc" "$_arg_subcommands";
        do
            if test -n "$child"; then
                local _startString _endString gapVar;
                _startString="$(sed 's|<^>.*||g' <<<"${child}")";
                _endString="$(sed 's|.*<^>||g' <<<"${child}")";
                mapfile -t _startString < <(echo "$_startString");
                mapfile -t _endString < <(echo "$_endString");
                local i=0;
                local firstChild=false;
                ! "$firstChild" && echo -e "OPTIONS:" || echo -e 'SUBCOMMANDS:' && firstChild=true;
                for line in "${_startString[@]}";
                do
                    gapVar="$(
					for t in $(seq $((30 - ${#line}))); do
						echo -n " "
					done
				)";
                    echo -e "    $line${gapVar}${_endString[$i]}";
                    i=$((i+1));
                done;
                echo;
            fi;
        done;
        if test -n "$_arg_examples"; then
            echo -e "EXAMPLES:";
            while read -r line; do
                echo -e "    $line";
            done < <(echo "$_arg_examples");
            echo;
        fi;
        if test -n "$_arg_footer_msg"; then
            echo -e "$_arg_footer_msg\n";
        fi
    };
    function println::info () 
    { 
        test "$_arg_quiet" == "off" && echo -e "[%%%] ${WHITE}info${RC}: $@"
    };
    function println::warn () 
    { 
        test "$_arg_quiet" == "off" && echo -e "[***] ${YELLOW}warn${RC}: $@"
    };
    function println::error () 
    { 
        local _return_code=${2:-$?};
        local _source="${BB_ERR_SOURCE:-"${BASH_SOURCE[0]}"}";
        local _command="$1";
        test "${_PRINT_HELP:-no}" == yes && print_help 1>&2;
        echo -e "[!!!] \033[1;31mERROR\033[0m[$_return_code]: $_source[$BASH_LINENO]: $_command";
        case "${JOB:-"exit"}" in 
            exit)
                exit $_return_code
            ;;
            kill)
                kill -9 "$BASHPID"
            ;;
        esac
    };
    readonly RC='\033[0m' RED='\033[0;31m' BRED='\033[1;31m' GRAY='\033[1;30m';
    readonly BLUE='\033[0;34m' BBLUE='\033[1;34m' CYAN='\033[0;34m' BCYAN='\033[1;34m';
    readonly WHITE='\033[1;37m' GREEN='\033[0;32m' BGREEN='\033[1;32m' YELLOW='\033[1;33m';
    readonly PURPLE='\033[0;35m' BPURPLE='\033[1;35m' ORANGE='\033[0;33m';
    function io::file::check_newline () 
    { 
        local _input="$1";
        if ! [[ $(tail -c1 "$_input" | wc -l) -gt 0 ]]; then
            { 
                echo >> "$_input"
            };
        fi
    };
    function begins_with_short_option () 
    { 
        local first_option all_short_options='h';
        first_option="${1:0:1}";
        test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
    };
    function okay::man () 
    { 
        echo hmmm
    };
    function subcommand::new () 
    { 
        _positionals=();
        _arg_path=;
        _arg_codename=;
        function print_help () 
        { 
            println::helpgen "${_self_name^^}-${_subcommand_argv^^}" --short-desc "${SUBCOMMANDS_DESC[1]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "-c, --codename<^>Avoid directory-as-codename
-h, --help<^>Prints this help information" --examples "### The basic way:
${YELLOW}${_self_name} ${_subcommand_argv} awesome_project${RC}

### Pre-setting project codename, avoiding directory-path as codename:
${YELLOW}${_self_name} ${_subcommand_argv} --codename cake awesome_project${RC}

### Using a specific template for project initialization(core is default):
${YELLOW}${_self_name} ${_subcommand_argv} --template kernel awesome_project${RC}

### Random usage EXAMPLES just for referrence:
${YELLOW}${_self_name} ${_subcommand_argv} --template mesa graphics_lib
${_self_name} ${_subcommand_argv} --template=kernel vanilla_kernel --codename vkernel
${_self_name} ${_subcommand_argv} --codename=cakebaker foo/bakery${RC}"
        };
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                _key="$1";
                case "$_key" in 
                    --codename | -c)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_codename="$2";
                        shift
                    ;;
                    --codename=*)
                        _arg_codename="${_key##--codename=}"
                    ;;
                    -h | --help)
                        print_help;
                        exit 0
                    ;;
                    -h*)
                        print_help;
                        exit 0
                    ;;
                    *)
                        _last_positional="$1";
                        _positionals+=("$_last_positional");
                        _positionals_count=$((_positionals_count + 1))
                    ;;
                esac;
                shift;
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'path'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_path ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                test $# -gt 0 || break;
                eval "$_positional_name=\${1}" || println::error "Error during argument parsing." 1;
                shift;
            done
        };
        parse_commandline "$@";
        handle_passed_args_count;
        assign_positional_args 1 "${_positionals[@]}";
        _path_codename="${_arg_path##*/}";
        : "${_arg_codename:="$_path_codename"}";
        _arg_codename="$(tr -d '[:space:]' <<<"${_arg_codename,,}")";
        if test -e "$_arg_path"; then
            println::error "Destination \`$_arg_path\` already exists.\n\t  You may either remove that project dir or use a different path for setup." 1;
        fi;
        println::info "Setting up project at \`$_arg_path\`";
        mkdir -p "$_arg_path" || println::error "Failed to initialize the project directory";
        mkdir -p "$_arg_path/$_src_dir_name";
        cat <<'EOF' > "$_arg_path/$_src_dir_name/main.sh"
function main() {
	echo "Hello world";
}

EOF

        cat <<EOF > "$_arg_path/$_bashbox_meta_name"
NAME="$_path_codename"
CODENAME="$_arg_codename"
AUTHORS=("AXON <axonasif@gmail.com>")
VERSION="1.0"
DEPENDENCIES=()
REPOSITORY=""
EOF

        println::info "Initializing git version control for your project";
        if command -v git > /dev/null; then
            git init "$_arg_path" > /dev/null || { 
                _r=$?;
                rm -r "$_arg_path";
                println::error "Failed to initialize git at \`$_arg_path\`" $_r
            };
            echo -e '/target' > "$_arg_path/.gitignore";
        else
            rm -r "$_arg_path";
            println::error "git does not seem to be available, please install it" 1;
        fi
    };
    function subcommand::install () 
    { 
        function trim_leading_trailing () 
        { 
            local _stream="${1:-}";
            local _stdin;
            if test -z "${_stream}"; then
                { 
                    read -r _stdin;
                    _stream="$_stdin"
                };
            fi;
            _stream="${_stream#"${_stream%%[![:space:]]*}"}";
            _stream="${_stream%"${_stream##*[![:space:]]}"}";
            printf '%s\n' "$_stream"
        };
        function trim_string () 
        { 
            : "${1#"${1%%[![:space:]]*}"}";
            : "${_%"${_##*[![:space:]]}"}";
            printf '%s\n' "$_"
        };
        function trim_all () 
        { 
            set -f;
            set -- $*;
            printf '%s\n' "$*";
            set +f
        };
        function trim_quotes () 
        { 
            : "${1//\'}";
            printf '%s\n' "${_//\"}"
        };
        function sync_repometa () 
        { 
            local _registry_meta_url _registry_lastsync_file;
            readonly _registry_meta_url="https://raw.githubusercontent.com/bashbox/registry/main/registry.meta";
            readonly _registry_lastsync_file="${_bashbox_home}/.registry.lastsync" && touch "$_registry_lastsync_file";
            local _user_repo _check_file _branch;
            readonly _user_repo="bashbox/registry";
            readonly _check_file="registry.meta";
            readonly _branch="main";
            local _lock_file="$_bashbox_home/.registry.lastdate";
            local _date && _date="$(date '+%d-%m')";
            if test "$_arg_offline" == "off"; then
                { 
                    touch "$_lock_file";
                    if [ "$_arg_syncmeta" == "on" ] || [ "$(< "$_lock_file")" != "$_date" ]; then
                        { 
                            echo "$_date" > "$_lock_file";
                            println::info "Syncing repository metadata";
                            local _local_sha _remote_sha;
                            _local_sha="$(< "$_registry_lastsync_file")";
                            _remote_sha="$(curl --silent "${_github_api_root}/repos/${_user_repo}/contents/${_check_file}?ref=${_branch}" 								| head -n4 | grep -I '"sha":' | sed -E 's/.*"([^"]+)".*/\1/')";
                            readonly _local_sha _remote_sha;
                            if test "$_arg_syncmeta" == "on" || test "$_local_sha" != "$_remote_sha"; then
                                { 
                                    println::info "Updating registry.meta";
                                    curl --silent -o "$_registry_meta_file" -L "$_registry_meta_url";
                                    echo "$_remote_sha" > "$_registry_lastsync_file"
                                };
                            fi
                        };
                    fi
                };
            fi
        };
        local _arg_force=off;
        local _arg_syncmeta=off;
        local _arg_eval;
        for _arg_eval in "force" "syncmeta";
        do
            { 
                case "$@" in 
                    *${_arg_eval}*)
                        eval "_arg_${_arg_eval}=on"
                    ;;
                esac
            };
        done;
        unset _arg_eval;
        local _github_api_root _registry_meta_file;
        readonly _registry_meta_file="${_bashbox_home}/registry.meta" && touch "$_registry_meta_file";
        readonly _github_api_root="https://api.github.com";
        sync_repometa;
        local _box _box_dir _repo_root_link _gitmod_file;
        local _path _url _install_path _install_executable _built_executable;
        local _repo_name _tag_name;
        for _box in "${@}";
        do
            { 
                if [[ "$_box" =~ ^-- ]]; then
                    { 
                        continue
                    };
                fi;
                _repo_name="${_box%%::*}";
                _repo_root_link="$(grep ".*/$_repo_name" "$_registry_meta_file")" || println::error "No such box as $_repo_name was found" 1;
                _tag_name="${_box##*::}" && { 
                    if [[ ! "$_tag_name" =~ ^[0-9]+\.[0-9]+ ]]; then
                        { 
                            _tag_name="$(curl --silent 					"${_github_api_root}/repos/${_repo_root_link##http*github.com\/}/tags" 						| head -n3 						| grep -m 1 -Po '"name": "\K.*?(?=")')"
                        };
                    fi
                };
                _box_dir="$_bashbox_registrydir/${_repo_name}-${_tag_name}";
                if test "$EXPORT_USEMOL" == "true"; then
                    { 
                        export "_usemol_${_repo_name}=${_box_dir}/src"
                    };
                fi;
                if test -e "$_box_dir"; then
                    { 
                        if [ "$_arg_force" == "off" ] && [ -e "$_box_dir/$_bashbox_meta_name" ]; then
                            { 
                                return 0
                            };
                        else
                            { 
                                rm -rf "$_box_dir"
                            };
                        fi
                    };
                fi;
                mkdir -p "$_box_dir";
                println::info "Downloading box $_repo_name $_tag_name";
                curl --silent -L "${_repo_root_link}/archive/refs/tags/${_tag_name}.tar.gz" | tar --strip-components=1 -C "$_box_dir" -xpzf -;
                _gitmod_file="$_box_dir/.gitmodules";
                if test -e "$_gitmod_file"; then
                    { 
                        println::info "Resolving submodules";
                        while read -r _line; do
                            { 
                                _line="${_line%%:*}";
                                _path="$(sed "${_line}q;d" "$_gitmod_file" 					| cut -d '=' -f2 | trim_leading_trailing)";
                                _url="$(sed "$(( _line + 1 ))q;d" "$_gitmod_file" 					| cut -d '=' -f2 | trim_leading_trailing)";
                                _install_path="${_box_dir}/${_path}";
                                println::info "Downloading submodule: $_path";
                                mkdir -p "$_install_path";
                                curl --silent -L "${_url}/archive/refs/heads/main.tar.gz" | tar --strip-components=1 -C "$_install_path" -xpzf -
                            };
                        done < <(grep -n 'path.*=' "$_gitmod_file")
                    };
                fi;
                if test -e "$_box_dir/$_src_dir_name/main.sh"; then
                    { 
                        println::info "Compiling $_box in release mode";
                        "$___self" build "$_box_dir" --release 2>&1 || { 
                            println::error "Errors were found while compiling $_box, operation failed" 1
                        };
                        _built_executable="$_box_dir/target/release/executable";
                        _install_executable="$_bashbox_bindir/$_box";
                        chmod +x "$_built_executable";
                        ln -srf "$_built_executable" "$_install_executable";
                        chmod +x "$_install_executable";
                        println::info "$_box was successfully installed"
                    };
                else
                    { 
                        println::info "$_box was installed as a library"
                    };
                fi
            };
        done
    };
    function subcommand::build () 
    { 
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[3]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "--release<^>Build in release mode
--debug<^>Build in debug mode(default)
--run<^>Auto-run the executable after build
--<^>Pass arguments to your compiled program
-h, --help<^>Prints this help information" --examples "### The basic way:
# Buld the project in your current directory hierarchy in release-mode
${YELLOW}${_self_name} ${_subcommand_argv} --release${RC}

### Build project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} --release /home/me/awesome_project${RC}

### Pass arguments to the compiled executable and auto-run it after build
${YELLOW}${_self_name} ${_subcommand_argv} --release --release -- arg1 arg2 \"string arg\" and-so-on${RC}
"
        };
        _positionals=();
        _arg_path=;
        _arg_debug="off";
        _arg_release="off";
        _arg_run="off";
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                { 
                    _key="$1";
                    case "$_key" in 
                        --debug)
                            _arg_debug="on"
                        ;;
                        --release)
                            _arg_release="on"
                        ;;
                        --run)
                            _arg_run="on"
                        ;;
                        --help)
                            print_help && exit 0
                        ;;
                        --)
                            return 0
                        ;;
                        *)
                            _last_positional="$1";
                            _positionals+=("$_last_positional");
                            _positionals_count=$((_positionals_count + 1))
                        ;;
                    esac;
                    shift
                };
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'path'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_path ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                { 
                    test $# -gt 0 || break;
                    eval "$_positional_name=\${1}" || println::error "Error during argument parsing, possibly an Argbash bug." 1;
                    shift
                };
            done
        };
        function parse_runargs () 
        { 
            for _arg in "${@}";
            do
                { 
                    if test "$_arg" != '--'; then
                        { 
                            shift
                        };
                    else
                        { 
                            shift;
                            _run_target_args=("$@");
                            readonly _run_target_args;
                            break
                        };
                    fi
                };
            done
        };
        parse_commandline "$@";
        parse_runargs "$@";
        assign_positional_args 1 "${_positionals[@]}";
        function gettop () 
        { 
            local TOPFILE="$_bashbox_meta_name";
            local TOPDIR="$_src_dir_name";
            local TOP=;
            local T;
            if [ -n "$TOP" ] && [ -f "$TOP/$TOPFILE" ] && [ -d "$TOPFILE" ]; then
                { 
                    ( cd "$TOP";
                    echo "$PWD" )
                };
            else
                { 
                    if [ -f "$TOPFILE" ] && [ -d "$TOPDIR" ]; then
                        { 
                            echo "$PWD"
                        };
                    else
                        { 
                            local HERE="$PWD";
                            while [ \( ! \( -f "$TOPFILE" -a "$TOPDIR" \) \) -a \( "$PWD" != "/" \) ]; do
                                { 
                                    \cd ..;
                                    T="$(readlink -f "$PWD")"
                                };
                            done;
                            \cd "$HERE";
                            if [ -f "$T/$TOPFILE" ] && [ -d "$T/$TOPDIR" ]; then
                                { 
                                    echo "$T"
                                };
                            fi
                        };
                    fi
                };
            fi
        };
        : "${_arg_path:="$PWD"}";
        _arg_path="$(readlink -f "$_arg_path")";
        if test ! -d "$_arg_path/$_src_dir_name" || test ! -e "$_arg_path/$_bashbox_meta_name"; then
            { 
                _top="$(gettop)";
                if test -n "$_top"; then
                    { 
                        _arg_path="$_top";
                        unset _top
                    };
                else
                    { 
                        println::error "$_arg_path is not a valid bashbox project" 1
                    };
                fi
            };
        fi;
        readonly _arg_path;
        readonly _src_dir="$_arg_path/$_src_dir_name";
        readonly _target_dir="$_arg_path/target";
        readonly _target_debug_dir="$_target_dir/debug";
        readonly _bashbox_meta="$_arg_path/$_bashbox_meta_name";
        readonly _target_release_dir="$_target_dir/release";
        case "$FUNCNAME" in 
            "subcommand::build" | "subcommand::run")
                _build_variant="$(
			if test "$_arg_release" == "on"; then {
				echo "${_target_release_dir##*/}";
			} else {
				echo "${_target_debug_dir##*/}";
			} fi
		)";
                readonly _build_variant;
                readonly _target_workdir="$_target_dir/$_build_variant";
                readonly _used_symbols_statfile="$_target_workdir/.used_symbols";
                readonly _compiled_mod_bundle="$_target_workdir/.lib.compiled.mod";
                for _dir in "$_target_debug_dir" "$_target_release_dir";
                do
                    { 
                        mkdir -p "$_dir"
                    };
                done;
                io::file::check_newline "$_bashbox_meta";
                rsync -a --delete "$_src_dir/" "$_target_workdir";
                echo > "$_used_symbols_statfile";
                source "$_bashbox_meta";
                for _box in "${DEPENDENCIES[@]}";
                do
                    { 
                        EXPORT_USEMOL="true" subcommand::install "$_box"
                    };
                done;
                readonly _target_workfile="$_target_workdir/$NAME"
            ;;
        esac;
        function Resolve::Colons () 
        { 
            awk '{$1=$1;print}' <<< "$1" | sed "s|^use box::||; s|^use ||; s|;$||; s|::|/|g; s|/\*$||"
        };
        function Resolve::SymbolPath () 
        { 
            local _input="$1";
            local _parent;
            _parent="$(
			if grep "^use box::" <<<"$_input" 1>/dev/null; then
				echo "$_src_dir";
			else
				echo "$PWD";
			fi
		)";
            echo "$_parent/$(Resolve::Colons "$_input")"
        };
        function Resolve::IsMain () 
        { 
            if test "$_target_workdir/main" == "$_input"; then
                { 
                    true
                };
            else
                { 
                    false
                };
            fi
        };
        function Resolve::UseSymbols () 
        { 
            local _input="$1";
            if Resolve::IsMain; then
                { 
                    _input="main"
                };
            fi;
            local _parsed_input && _parsed_input="$(Resolve::Colons "$_input")";
            local _parsed_input_name="${_parsed_input##*/}" && { 
                local _modname="${_parsed_input_name}";
                _parsed_input="$(sed "s|${_parsed_input_name}$|${_parsed_input_name#_}|" <<<"$_parsed_input")";
                unset _parsed_input_name
            };
            local _ref="_usemol_${_parsed_input%%/*}";
            local _src && { 
                if grep 'use box::' <<< "$_input" > /dev/null; then
                    { 
                        _src="$_target_workdir"
                    };
                else
                    if test -v "$_ref"; then
                        { 
                            _src="${!_ref}";
                            _parsed_input="${_parsed_input#*/}"
                        };
                    else
                        { 
                            _src="$PWD"
                        };
                    fi;
                fi;
                _parsed_input="$_src/$_parsed_input"
            };
            if test "$_arg_verbose" == "off"; then
                { 
                    echo -e "   ${BGREEN}Compiling${RC} $_modname"
                };
            else
                { 
                    echo -e "---------- $_modname"
                };
            fi;
            if test "${_modname::1}" == "_" || ! grep "^${_parsed_input}.sh$" "$_used_symbols_statfile" > /dev/null; then
                { 
                    if test ! -e "${_parsed_input}.sh" && test ! -e "${_parsed_input}"; then
                        { 
                            println::error "$_input is missing" 1
                        };
                    fi;
                    if grep '\*;$' <<< "$(awk '{$1=$1;print}' <<<"$_input")" > /dev/null; then
                        { 
                            for _modFile in "$_parsed_input/"*;
                            do
                                { 
                                    io::file::check_newline "$_modFile"
                                };
                            done;
                            cat "$_parsed_input/"* > "$_compiled_mod_bundle.sh";
                            _parsed_input="$_compiled_mod_bundle"
                        };
                    else
                        if test ! -e "${_parsed_input}.sh" && test -d "$_parsed_input"; then
                            { 
                                _parsed_input="$_parsed_input/mod"
                            };
                        fi;
                    fi;
                    cd "$(dirname "$_parsed_input")";
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo -e "${RED}PWD${RC}: $PWD";
                            echo -e "${CYAN}File${RC}: ${_parsed_input}.sh"
                        };
                    fi;
                    mapfile -t _use_symbols < <(grep -E 'use .*;$' "${_parsed_input}.sh" | grep -v '#' | awk '{$1=$1;print}' || true);
                    : ${_last_parsed_input:="${_parsed_input}"};
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo -e "${PURPLE}Caller${RC}: $_last_parsed_input\n"
                        };
                    fi;
                    for _symbol in "${_use_symbols[@]}";
                    do
                        ( _last_parsed_input="${_parsed_input}";
                        Resolve::UseSymbols "$_symbol" );
                    done;
                    if test "${_parsed_input}.sh" != "${_last_parsed_input}.sh"; then
                        { 
                            io::file::check_newline "${_parsed_input}.sh";
                            bash -n "${_parsed_input}.sh";
                            sed -i -e "/$(sed 's|*|\\*|g' <<<${_input})/{r ${_parsed_input}.sh" -e 'd}' "${_last_parsed_input}.sh"
                        };
                    fi;
                    echo "${_parsed_input}.sh" >> "$_used_symbols_statfile";
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo "$_parsed_input.sh ++ ${_last_parsed_input}.sh($_input)"
                        };
                    fi
                };
            fi
        };
        if test -e "$_arg_path/build.sh"; then
            { 
                source "$_arg_path/build.sh";
                if declare -f bashbox_before_build | head -n0; then
                    { 
                        bashbox_before_build
                    };
                fi
            };
        fi;
        cd "$_target_workdir";
        Resolve::UseSymbols "$_target_workdir/main";
        local _bb_bootstrap;
        _bb_bootstrap=$(declare -f bb_bootstrap_header) && { 
            _bb_bootstrap="${_bb_bootstrap#*{}";
            _bb_bootstrap="${_bb_bootstrap%\}}"
        };
        local _ran="$RANDOM";
        local _main_funcname="main@bashbox%${_ran}";
        local _tmp_target_workfile="$_target_workdir/.${NAME}.$_ran";
        local _shebang && { 
            _shebang='#!'"$(command -v env) bash"
        };
        echo "$_shebang" > "$_tmp_target_workfile";
        echo "function ${_main_funcname}() {" >> "$_tmp_target_workfile";
        echo "${_bb_bootstrap}" >> "$_tmp_target_workfile";
        declare -f 'println::error' >> "$_tmp_target_workfile";
        cat <<EOF >> "$_tmp_target_workfile"
___self="\$0";
___MAIN_FUNCNAME="$_main_funcname";
EOF

        cat "$_bashbox_meta" >> "$_tmp_target_workfile";
        cat "$_tmp_target_workfile" "$_target_workdir/main.sh" > "$_target_workfile";
        echo "main \"\$@\";" >> "$_target_workfile";
        rm "$_tmp_target_workfile";
        echo -e '}' >> "$_target_workfile";
        if test "$_build_variant" == "release"; then
            { 
                source "$_target_workfile";
                echo "$_shebang" > "$_target_workfile";
                declare -f "$_main_funcname" >> "$_target_workfile"
            };
        fi;
        echo "${_main_funcname} \"\$@\"" >> "$_target_workfile";
        if declare -f bashbox_after_build | head -n0; then
            { 
                bashbox_after_build
            };
        fi;
        chmod +x "$_target_workfile";
        if test "$_arg_verbose" == "off"; then
            { 
                local _is_optimized;
                _is_optimized=$(
			if test "$_build_variant" == "release"; then {
				echo "optimized"
			} else {
				echo "unoptimized + debuginfo"
			} fi
		);
                echo -e "   ${BGREEN}Finished${RC} $_build_variant [${_is_optimized}] target(s) in ${SECONDS}s";
                unset _is_optimized
            };
        fi;
        if test "$_arg_run" == "on"; then
            { 
                "$_target_workfile" "${_run_target_args[@]}"
            };
        fi
    };
    function subcommand::run () 
    { 
        println::error "This command is temporarily unavailable, under a rewrite";
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[2]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "--release<^>Run in release mode
--debug<^>Run in debug mode(default)
--<^>Pass arguments to your compiled program
-h, --help<^>Prints this help information" --examples "### The basic way:
# Run the project in your current directory hierarchy in release-mode
${YELLOW}${_self_name} ${_subcommand_argv} --release${RC}

### Run project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} --release /home/me/awesome_project${RC}

### Pass arguments to the compiled executable
${YELLOW}${_self_name} ${_subcommand_argv} --release -- arg1 arg2 \"string arg\" and-so-on${RC}
"
        };
        function __use_func () 
        { 
            for _input in "${@}";
            do
                { 
                    local _input="$_input";
                    local _ref="_usemol_${_input%%::*}";
                    local _src && { 
                        if grep "^box::.*" <<< "$_input" > /dev/null; then
                            { 
                                _src="$_main_src_dir"
                            };
                        else
                            if test -v "$_ref"; then
                                { 
                                    _src="${!_ref}";
                                    _input="${_input#*::}"
                                };
                            else
                                { 
                                    _src="$(readlink -f "${BB_SOURCE}")" && _src="${_src%/*}"
                                };
                            fi;
                        fi
                    };
                    local _parsed_input && _parsed_input="$(sed "s|box::||g; s|::|/|g" <<<"$_input")";
                    local _parsed_input_name="${_parsed_input##*/}";
                    _parsed_input="$(sed "s|${_parsed_input_name}$|${_parsed_input_name#_}|" <<<"$_parsed_input")";
                    unset _parsed_input_name;
                    function source_fromFile () 
                    { 
                        local _mod="$1";
                        local _modname="${_input##*::}";
                        function source_call () 
                        { 
                            builtin source "${_mod}.sh" "${BB_USE_ARGS[@]}" || { 
                                println::error "Syntax/internal errors were detected in $_mod"
                            };
                            echo "$_mod" >> "$_used_symbols_statfile" || { 
                                println::error "Failed to register $_mod in log"
                            }
                        };
                        if test "${_modname::1}" == "_"; then
                            { 
                                source_call
                            };
                        else
                            if ! grep "^${_mod}$" "$_used_symbols_statfile" > /dev/null; then
                                { 
                                    source_call
                                };
                            fi;
                        fi
                    };
                    function source_fromDir () 
                    { 
                        local _dir="$1";
                        for _mod in "$_dir/"*;
                        do
                            { 
                                source_fromFile "${_mod%.sh}"
                            };
                        done
                    };
                    function fetchLib_fromPath () 
                    { 
                        local _mod="$1";
                        local _paths;
                        local _found_file_mods=();
                        local _found_dir_mods=();
                        mapfile -t _paths < <(sed 's|:|\n|g' <<<"${BASHBOX_LIB_PATH:-}");
                        for _path in "${_paths[@]}";
                        do
                            { 
                                if test -e "$_path/$_mod"; then
                                    { 
                                        _found_file_mods+=("$_path/$_mod");
                                        break
                                    };
                                else
                                    if test -d "$_path/$_mod"; then
                                        { 
                                            _found_dir_mods+=("$_path/$_mod");
                                            break
                                        };
                                    fi;
                                fi
                            };
                        done;
                        if test -n "${_found_file_mods[*]}" || test -n "${_found_dir_mods[*]}"; then
                            { 
                                for _mod in "${_found_file_mods[@]}";
                                do
                                    { 
                                        source_fromFile "$_mod"
                                    };
                                done;
                                for _mod in "${_found_dir_mods[@]}";
                                do
                                    { 
                                        source_fromDir "$_mod"
                                    };
                                done;
                                return 0
                            };
                        else
                            { 
                                return 1
                            };
                        fi
                    };
                    if test -e "$_src/${_parsed_input}.sh"; then
                        { 
                            source_fromFile "$_src/${_parsed_input}"
                        };
                    else
                        if test -e "$_src/${_parsed_input}/mod.sh"; then
                            { 
                                source_fromFile "${_src}/${_parsed_input}/mod"
                            };
                        else
                            if test -e "$_bashbox_registrydir/${_parsed_input}.sh"; then
                                { 
                                    source_fromFile "$_bashbox_registrydir/${_parsed_input}"
                                };
                            else
                                if grep '/\*$' <<< "$_parsed_input" > /dev/null; then
                                    { 
                                        local _dir;
                                        _dir="$(sed 's|/\*$||' <<<"$_parsed_input")";
                                        if test -d "$_src/$_dir"; then
                                            { 
                                                source_fromDir "$_src/$_dir"
                                            };
                                        else
                                            if test -d "$_bashbox_registrydir/$_dir"; then
                                                { 
                                                    source_fromDir "$_bashbox_registrydir/$_dir"
                                                };
                                            else
                                                { 
                                                    println::error "No such module tree as $_input was found"
                                                };
                                            fi;
                                        fi
                                    };
                                else
                                    { 
                                        println::error "No such module as $_input was found"
                                    };
                                fi;
                            fi;
                        fi;
                    fi
                };
            done;
            unset BB_USE_ARGS
        };
        _positionals=();
        _arg_path=;
        _arg_debug="off";
        _arg_release="off";
        _arg_run="off";
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                { 
                    _key="$1";
                    case "$_key" in 
                        --debug)
                            _arg_debug="on"
                        ;;
                        --release)
                            _arg_release="on"
                        ;;
                        --run)
                            _arg_run="on"
                        ;;
                        --help)
                            print_help && exit 0
                        ;;
                        --)
                            return 0
                        ;;
                        *)
                            _last_positional="$1";
                            _positionals+=("$_last_positional");
                            _positionals_count=$((_positionals_count + 1))
                        ;;
                    esac;
                    shift
                };
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'path'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_path ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                { 
                    test $# -gt 0 || break;
                    eval "$_positional_name=\${1}" || println::error "Error during argument parsing, possibly an Argbash bug." 1;
                    shift
                };
            done
        };
        function parse_runargs () 
        { 
            for _arg in "${@}";
            do
                { 
                    if test "$_arg" != '--'; then
                        { 
                            shift
                        };
                    else
                        { 
                            shift;
                            _run_target_args=("$@");
                            readonly _run_target_args;
                            break
                        };
                    fi
                };
            done
        };
        parse_commandline "$@";
        parse_runargs "$@";
        assign_positional_args 1 "${_positionals[@]}";
        function gettop () 
        { 
            local TOPFILE="$_bashbox_meta_name";
            local TOPDIR="$_src_dir_name";
            local TOP=;
            local T;
            if [ -n "$TOP" ] && [ -f "$TOP/$TOPFILE" ] && [ -d "$TOPFILE" ]; then
                { 
                    ( cd "$TOP";
                    echo "$PWD" )
                };
            else
                { 
                    if [ -f "$TOPFILE" ] && [ -d "$TOPDIR" ]; then
                        { 
                            echo "$PWD"
                        };
                    else
                        { 
                            local HERE="$PWD";
                            while [ \( ! \( -f "$TOPFILE" -a "$TOPDIR" \) \) -a \( "$PWD" != "/" \) ]; do
                                { 
                                    \cd ..;
                                    T="$(readlink -f "$PWD")"
                                };
                            done;
                            \cd "$HERE";
                            if [ -f "$T/$TOPFILE" ] && [ -d "$T/$TOPDIR" ]; then
                                { 
                                    echo "$T"
                                };
                            fi
                        };
                    fi
                };
            fi
        };
        : "${_arg_path:="$PWD"}";
        _arg_path="$(readlink -f "$_arg_path")";
        if test ! -d "$_arg_path/$_src_dir_name" || test ! -e "$_arg_path/$_bashbox_meta_name"; then
            { 
                _top="$(gettop)";
                if test -n "$_top"; then
                    { 
                        _arg_path="$_top";
                        unset _top
                    };
                else
                    { 
                        println::error "$_arg_path is not a valid bashbox project" 1
                    };
                fi
            };
        fi;
        readonly _arg_path;
        readonly _src_dir="$_arg_path/$_src_dir_name";
        readonly _target_dir="$_arg_path/target";
        readonly _target_debug_dir="$_target_dir/debug";
        readonly _bashbox_meta="$_arg_path/$_bashbox_meta_name";
        readonly _target_release_dir="$_target_dir/release";
        case "$FUNCNAME" in 
            "subcommand::build" | "subcommand::run")
                _build_variant="$(
			if test "$_arg_release" == "on"; then {
				echo "${_target_release_dir##*/}";
			} else {
				echo "${_target_debug_dir##*/}";
			} fi
		)";
                readonly _build_variant;
                readonly _target_workdir="$_target_dir/$_build_variant";
                readonly _used_symbols_statfile="$_target_workdir/.used_symbols";
                readonly _compiled_mod_bundle="$_target_workdir/.lib.compiled.mod";
                for _dir in "$_target_debug_dir" "$_target_release_dir";
                do
                    { 
                        mkdir -p "$_dir"
                    };
                done;
                io::file::check_newline "$_bashbox_meta";
                rsync -a --delete "$_src_dir/" "$_target_workdir";
                echo > "$_used_symbols_statfile";
                source "$_bashbox_meta";
                for _box in "${DEPENDENCIES[@]}";
                do
                    { 
                        EXPORT_USEMOL="true" subcommand::install "$_box"
                    };
                done;
                readonly _target_workfile="$_target_workdir/$NAME"
            ;;
        esac;
        cat <<'EOF' > "$_target_workfile"
___self="$0";
EOF

        cat "$_bashbox_meta" >> "$_target_workfile";
        declare -f bb_bootstrap_header | tail -n +3 | head -n -1 >> "$_target_workfile";
        cat <<'EOF' >> "$_target_workfile"
	alias use='BB_USE_ARGS=("$@"); BB_SOURCE="${BASH_SOURCE[0]}" __use_func';
	_main_src_dir="$(dirname "$(readlink -f "$0")")";
	_used_symbols_statfile="$_main_src_dir/.used_symbols";
EOF

        declare -f 'println::error' >> "$_target_workfile";
        declare -f __use_func >> "$_target_workfile";
        cat "$_target_workdir/main.sh" >> "$_target_workfile";
        echo -e "\nmain \"\$@\";" >> "$_target_workfile";
        chmod +x "$_target_workfile";
        "$_target_workfile" "${_run_target_args[@]}"
    };
    function subcommand::selfinstall () 
    { 
        local PATH="$_bashbox_bindir:$PATH";
        local _path;
        while read -r _path; do
            { 
                if test -w "$_path"; then
                    { 
                        local _target_install_dir="$_path";
                        break
                    };
                fi
            };
        done < <(echo -e "${PATH//:/\\n}");
        if ! test -v _target_install_dir; then
            { 
                println::error "Failed to retrieve a usable PATH directory" 1
            };
        fi;
        function check_shellrc_key () 
        { 
            local _input_file="$1";
            if grep "source.*\.bashbox/env" "$_input_file" > /dev/null; then
                { 
                    return 0
                };
            else
                { 
                    return 1
                };
            fi
        };
        local _shellrcs=("$HOME/.bashrc" "$HOME/.kshrc" "$HOME/.zshrc" "$HOME/.config/fish/config.fish");
        for _shellrc in "${_shellrcs[@]}";
        do
            { 
                if test -e "$_shellrc" && ! check_shellrc_key "$_shellrc"; then
                    { 
                        case "$_shellrc" in 
                            "${_shellrcs[0]}" | "${_shellrcs[1]}" | "${_shellrcs[2]}")
                                echo "source \"$bashbox_posix_envfile\";" >> "$_shellrc"
                            ;;
                            "${_shellrcs[3]}")
                                echo "source \"$_bashbox_fish_envfile\";" >> "$_shellrc"
                            ;;
                        esac
                    };
                fi
            };
        done;
        println::info "Installing to $_target_install_dir";
        local _target_full_path="$_target_install_dir/$NAME";
        echo '#!/usr/bin/env bash' > "$_target_full_path";
        declare -f "${___MAIN_FUNCNAME}" >> "$_target_full_path";
        echo "${___MAIN_FUNCNAME} \"\$@\";" >> "$_target_full_path";
        chmod +x "$_target_full_path";
        println::info "Installation complete, now restart your shell and run \`$NAME --help\` to get started"
    };
    function subcommand::clean () 
    { 
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[4]}" --usage "${_self_name} $_subcommand_argv <path>" --examples "### The basic way:
${YELLOW}${_self_name} ${_subcommand_argv}${RC} # Cleans the project in your current directory

### Clean project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} /home/me/awesome_project${RC}"
        };
        _positionals=();
        _arg_path=;
        _arg_debug="off";
        _arg_release="off";
        _arg_run="off";
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                { 
                    _key="$1";
                    case "$_key" in 
                        --debug)
                            _arg_debug="on"
                        ;;
                        --release)
                            _arg_release="on"
                        ;;
                        --run)
                            _arg_run="on"
                        ;;
                        --help)
                            print_help && exit 0
                        ;;
                        --)
                            return 0
                        ;;
                        *)
                            _last_positional="$1";
                            _positionals+=("$_last_positional");
                            _positionals_count=$((_positionals_count + 1))
                        ;;
                    esac;
                    shift
                };
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'path'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_path ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                { 
                    test $# -gt 0 || break;
                    eval "$_positional_name=\${1}" || println::error "Error during argument parsing, possibly an Argbash bug." 1;
                    shift
                };
            done
        };
        function parse_runargs () 
        { 
            for _arg in "${@}";
            do
                { 
                    if test "$_arg" != '--'; then
                        { 
                            shift
                        };
                    else
                        { 
                            shift;
                            _run_target_args=("$@");
                            readonly _run_target_args;
                            break
                        };
                    fi
                };
            done
        };
        parse_commandline "$@";
        parse_runargs "$@";
        assign_positional_args 1 "${_positionals[@]}";
        function gettop () 
        { 
            local TOPFILE="$_bashbox_meta_name";
            local TOPDIR="$_src_dir_name";
            local TOP=;
            local T;
            if [ -n "$TOP" ] && [ -f "$TOP/$TOPFILE" ] && [ -d "$TOPFILE" ]; then
                { 
                    ( cd "$TOP";
                    echo "$PWD" )
                };
            else
                { 
                    if [ -f "$TOPFILE" ] && [ -d "$TOPDIR" ]; then
                        { 
                            echo "$PWD"
                        };
                    else
                        { 
                            local HERE="$PWD";
                            while [ \( ! \( -f "$TOPFILE" -a "$TOPDIR" \) \) -a \( "$PWD" != "/" \) ]; do
                                { 
                                    \cd ..;
                                    T="$(readlink -f "$PWD")"
                                };
                            done;
                            \cd "$HERE";
                            if [ -f "$T/$TOPFILE" ] && [ -d "$T/$TOPDIR" ]; then
                                { 
                                    echo "$T"
                                };
                            fi
                        };
                    fi
                };
            fi
        };
        : "${_arg_path:="$PWD"}";
        _arg_path="$(readlink -f "$_arg_path")";
        if test ! -d "$_arg_path/$_src_dir_name" || test ! -e "$_arg_path/$_bashbox_meta_name"; then
            { 
                _top="$(gettop)";
                if test -n "$_top"; then
                    { 
                        _arg_path="$_top";
                        unset _top
                    };
                else
                    { 
                        println::error "$_arg_path is not a valid bashbox project" 1
                    };
                fi
            };
        fi;
        readonly _arg_path;
        readonly _src_dir="$_arg_path/$_src_dir_name";
        readonly _target_dir="$_arg_path/target";
        readonly _target_debug_dir="$_target_dir/debug";
        readonly _bashbox_meta="$_arg_path/$_bashbox_meta_name";
        readonly _target_release_dir="$_target_dir/release";
        case "$FUNCNAME" in 
            "subcommand::build" | "subcommand::run")
                _build_variant="$(
			if test "$_arg_release" == "on"; then {
				echo "${_target_release_dir##*/}";
			} else {
				echo "${_target_debug_dir##*/}";
			} fi
		)";
                readonly _build_variant;
                readonly _target_workdir="$_target_dir/$_build_variant";
                readonly _used_symbols_statfile="$_target_workdir/.used_symbols";
                readonly _compiled_mod_bundle="$_target_workdir/.lib.compiled.mod";
                for _dir in "$_target_debug_dir" "$_target_release_dir";
                do
                    { 
                        mkdir -p "$_dir"
                    };
                done;
                io::file::check_newline "$_bashbox_meta";
                rsync -a --delete "$_src_dir/" "$_target_workdir";
                echo > "$_used_symbols_statfile";
                source "$_bashbox_meta";
                for _box in "${DEPENDENCIES[@]}";
                do
                    { 
                        EXPORT_USEMOL="true" subcommand::install "$_box"
                    };
                done;
                readonly _target_workfile="$_target_workdir/$NAME"
            ;;
        esac;
        rm -rf "$_target_dir"
    };
    function print_help () 
    { 
        println::helpgen "${_self_name^^}" --short-desc "Wannabe bash compiler" --usage "${_self_name} [OPTIONAL-OPTIONS] [SUBCOMMAND] <subcommand-arguments>" --options-desc "-V, --version<^>Print version info and exit
-v, --verbose<^>Use very verbose output
-q, --quiet<^>No output printed to stdout
--offline<^>Run without checking for update
-h, --help<^>Prints this help information" --subcommands "new<^>${SUBCOMMANDS_DESC[1]}
build<^>${SUBCOMMANDS_DESC[2]}
clean<^>${SUBCOMMANDS_DESC[3]}
install<^>${SUBCOMMANDS_DESC[4]}
selfinstall<^>${SUBCOMMANDS_DESC[5]}" --footer-msg "Try '${_self_name} <subcommand> --help' for more information on a specific command.
For bugreports: $REPOSITORY"
    };
    function main () 
    { 
        _self_name="${___self##*/}";
        _arg_verbose=off;
        _arg_quiet=off;
        _arg_offline=off;
        for _arg in "${@}";
        do
            { 
                if test "$_arg" != "--" && grep -E '\-\w+' <<< "$_arg" > /dev/null; then
                    { 
                        case "$_arg" in 
                            --verbose | -v)
                                _arg_verbose=on
                            ;;
                            --quiet | -q)
                                _arg_quiet=on
                            ;;
                            --offline)
                                _arg_offline=on
                            ;;
                            --version | -V)
                                echo "$VERSION";
                                exit 0
                            ;;
                            --help | -h*)
                                print_help && exit 0
                            ;;
                        esac;
                        shift
                    };
                else
                    { 
                        break
                    };
                fi
            };
        done;
        unset _arg;
        _subcommand_argv="${1:-}" && shift || true;
        case "$_subcommand_argv" in 
            new | run | build | clean | install | selfinstall)
                subcommand::$_subcommand_argv "$@"
            ;;
            *)
                test -n "$_subcommand_argv" && println::warn "Unknown subcommand: $_subcommand_argv";
                print_help;
                test -n "$_subcommand_argv" && exit 1 || exit 0
            ;;
        esac;
        exit
    };
    main "$@"
}
main@bashbox%8089 "$@"
